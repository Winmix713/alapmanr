
<?php declare(strict_types=1); namespace FootballAPI; // Set strict error reporting error_reporting(E_ALL); ini_set('display_errors', '1'); // Set response headers header('Content-Type: application/json; charset=UTF-8'); header('Access-Control-Allow-Origin: *'); header('Access-Control-Allow-Methods: GET, OPTIONS'); header('Access-Control-Allow-Headers: Content-Type'); // Handle preflight requests if ($_SERVER['REQUEST_METHOD'] === 'OPTIONS') { http_response_code(204); exit(); } class FootballAPI { private const JSON_FILE = 'combined_matches.json'; private const DEFAULT_PAGE_SIZE = 100; private const MAX_PAGE_SIZE = 500; // Prevent excessive memory usage private array $matches = []; public function __construct() { $this->loadMatches(); } /** * Load matches from JSON file * throws \RuntimeException When file cannot be read */ private function loadMatches(): void { if (!is_file(self::JSON_FILE)) { throw new \RuntimeException("JSON file not found: " . self::JSON_FILE); } $jsonData = file_get_contents(self::JSON_FILE); if ($jsonData === false) { throw new \RuntimeException("Failed to read JSON file: " . self::JSON_FILE); } try { $data = json_decode($jsonData, true, 512, JSON_THROW_ON_ERROR); $this->matches = $data['matches'] ?? []; } catch (\JsonException $e) { throw new \RuntimeException("Invalid JSON data: " . $e->getMessage()); } } /** * Calculate percentage of matches where both teams scored */ private function calculateBothTeamsScoredPercentage(array $matches): float { $matchCount = count($matches); if ($matchCount === 0) { return 0.0; } $bothTeamsScoredCount = array_reduce($matches, function(int $count, array $match): int { // Validate score structure before accessing if (!isset($match['score']['home']) || !isset($match['score']['away'])) { return $count; } return $count + (($match['score']['home'] > 0 && $match['score']['away'] > 0) ? 1 : 0); }, 0); return round(($bothTeamsScoredCount / $matchCount) * 100, 2); } /** * Calculate average goals statistics */ private function calculateAverageGoals(array $matches): array { if (empty($matches)) { return [ 'average_total_goals' => 0.0, 'average_home_goals' => 0.0, 'average_away_goals' => 0.0 ]; } $totalMatches = count($matches); $goals = array_reduce($matches, function(array $acc, array $match): array { // Validate score structure before accessing $homeGoals = isset($match['score']['home']) ? (int)$match['score']['home'] : 0; $awayGoals = isset($match['score']['away']) ? (int)$match['score']['away'] : 0; return [ 'total' => $acc['total'] + $homeGoals + $awayGoals, 'home' => $acc['home'] + $homeGoals, 'away' => $acc['away'] + $awayGoals ]; }, ['total' => 0, 'home' => 0, 'away' => 0]); return [ 'average_total_goals' => round($goals['total'] / $totalMatches, 2), 'average_home_goals' => round($goals['home'] / $totalMatches, 2), 'average_away_goals' => round($goals['away'] / $totalMatches, 2) ]; } /** * Calculate team form index based on recent games */ private function calculateFormIndex(array $matches, string $team, int $recentGames = 5): float { if (empty($team)) { return 0.0; } $teamMatches = array_values(array_filter($matches, function(array $match) use ($team): bool { return (isset($match['home_team']) && strcasecmp($match['home_team'], $team) === 0) || (isset($match['away_team']) && strcasecmp($match['away_team'], $team) === 0); })); if (empty($teamMatches)) { return 0.0; } $recentMatches = array_slice($teamMatches, 0, min(count($teamMatches), $recentGames)); $points = array_reduce($recentMatches, function(int $sum, array $match) use ($team): int { // Validate required fields exist if (!isset($match['home_team']) || !isset($match['away_team']) || !isset($match['score']['home']) || !isset($match['score']['away'])) { return $sum; } $isHomeTeam = strcasecmp($match['home_team'], $team) === 0; $homeScore = (int)$match['score']['home']; $awayScore = (int)$match['score']['away']; if ($isHomeTeam) { if ($homeScore > $awayScore) return $sum + 3; if ($homeScore === $awayScore) return $sum + 1; } else { if ($awayScore > $homeScore) return $sum + 3; if ($homeScore === $awayScore) return $sum + 1; } return $sum; }, 0); $maxPossiblePoints = count($recentMatches) * 3; return $maxPossiblePoints > 0 ? round(($points / $maxPossiblePoints) * 100, 2) : 0.0; } /** * Calculate head-to-head statistics between teams */ private function calculateHeadToHeadStats(array $matches): array { if (empty($matches)) { return [ 'home_wins' => 0, 'away_wins' => 0, 'draws' => 0, 'home_win_percentage' => 0.0, 'away_win_percentage' => 0.0, 'draw_percentage' => 0.0 ]; } // Filter out matches with invalid score structure $validMatches = array_filter($matches, function(array $match): bool { return isset($match['score']['home']) && isset($match['score']['away']); }); $totalMatches = count($validMatches); if ($totalMatches === 0) { return [ 'home_wins' => 0, 'away_wins' => 0, 'draws' => 0, 'home_win_percentage' => 0.0, 'away_win_percentage' => 0.0, 'draw_percentage' => 0.0 ]; } $stats = array_reduce($validMatches, function(array $acc, array $match): array { $homeScore = (int)$match['score']['home']; $awayScore = (int)$match['score']['away']; if ($homeScore > $awayScore) { $acc['home_wins']++; } elseif ($homeScore < $awayScore) { $acc['away_wins']++; } else { $acc['draws']++; } return $acc; }, ['home_wins' => 0, 'away_wins' => 0, 'draws' => 0]); return [ 'home_wins' => $stats['home_wins'], 'away_wins' => $stats['away_wins'], 'draws' => $stats['draws'], 'home_win_percentage' => round(($stats['home_wins'] / $totalMatches) * 100, 2), 'away_win_percentage' => round(($stats['away_wins'] / $totalMatches) * 100, 2), 'draw_percentage' => round(($stats['draws'] / $totalMatches) * 100, 2) ]; } /** * Filter matches based on query parameters */ private function filterMatches(array $matches, array $params): array { if (empty($params)) { return $matches; } return array_filter($matches, function(array $match) use ($params): bool { foreach ($params as $key => $value) { if (!$this->matchParameter($match, $key, $value)) { return false; } } return true; }); } /** * Check if a match parameter matches the specified condition */ private function matchParameter(array $match, string $key, string $value): bool { switch ($key) { case 'team': return $this->matchesTeam($match, $value); case 'home_team': return $this->matchesHomeTeam($match, $value); case 'away_team': return $this->matchesAwayTeam($match, $value); case 'date': return $this->matchesDate($match, $value); case (str_starts_with($key, 'score_')): return $this->matchesScore($match, $key, $value); case 'both_teams_scored': return $this->matchesBothTeamsScored($match, $value); default: return $this->matchesDefault($match, $key, $value); } } /** * Check if a team is involved in a match */ private function matchesTeam(array $match, string $value): bool { if (!isset($match['home_team']) || !isset($match['away_team'])) { return false; } return strcasecmp($match['home_team'], $value) === 0 || strcasecmp($match['away_team'], $value) === 0; } /** * Check if a team is the home team in a match */ private function matchesHomeTeam(array $match, string $value): bool { return isset($match['home_team']) && strcasecmp($match['home_team'], $value) === 0; } /** * Check if a team is the away team in a match */ private function matchesAwayTeam(array $match, string $value): bool { return isset($match['away_team']) && strcasecmp($match['away_team'], $value) === 0; } /** * Check if a match date matches the specified condition */ private function matchesDate(array $match, string $value): bool { if (!isset($match['date'])) { return false; } try { $matchDate = new \DateTime($match['date']); $paramDate = new \DateTime($value); return $matchDate >= $paramDate; } catch (\Exception $e) { return false; } } /** * Check if a match score matches the specified condition */ private function matchesScore(array $match, string $key, string $value): bool { $scoreType = str_replace('score_', '', $key); // Validate the score structure if (!isset($match['score']) || !is_array($match['score']) || !isset($match['score'][$scoreType])) { return false; } return (string)$match['score'][$scoreType] === $value; } /** * Check if both teams scored in a match */ private function matchesBothTeamsScored(array $match, string $value): bool { // Validate the score structure if (!isset($match['score']['home']) || !isset($match['score']['away'])) { return false; } $bothScored = ((int)$match['score']['home'] > 0 && (int)$match['score']['away'] > 0); $expected = filter_var($value, FILTER_VALIDATE_BOOLEAN, FILTER_NULL_ON_FAILURE); // Handle invalid boolean values if ($expected === null) { return false; } return $bothScored === $expected; } /** * Check if a match property matches the specified condition */ private function matchesDefault(array $match, string $key, string $value): bool { return isset($match[$key]) && strcasecmp((string)$match[$key], $value) === 0; } /** * Get a list of all available teams */ private function getAvailableTeams(array $matches): array { $teams = array_reduce($matches, function(array $acc, array $match): array { if (!empty($match['home_team'])) { $acc[] = $match['home_team']; } if (!empty($match['away_team'])) { $acc[] = $match['away_team']; } return $acc; }, []); // Case-insensitive unique values $uniqueTeams = []; foreach ($teams as $team) { $lowerTeam = strtolower($team); if (!isset($uniqueTeams[$lowerTeam])) { $uniqueTeams[$lowerTeam] = $team; } } return array_values($uniqueTeams); } /** * Calculate expected goals for a team */ private function calculateExpectedGoals(string $team, array $matches): float { if (empty($team) || empty($matches)) { return 0.0; } $teamMatches = array_filter($matches, function(array $match) use ($team): bool { return (isset($match['home_team']) && strcasecmp($match['home_team'], $team) === 0) || (isset($match['away_team']) && strcasecmp($match['away_team'], $team) === 0); }); if (empty($teamMatches)) { return 0.0; } // Filter out matches with invalid score structure $validMatches = array_filter($teamMatches, function(array $match) use ($team): bool { return isset($match['score']['home']) && isset($match['score']['away']); }); if (empty($validMatches)) { return 0.0; } $totalGoals = array_reduce($validMatches, function(float $sum, array $match) use ($team): float { $isHomeTeam = strcasecmp($match['home_team'] ?? '', $team) === 0; return $sum + ($isHomeTeam ? (float)$match['score']['home'] : (float)$match['score']['away']); }, 0.0); return round($totalGoals / count($validMatches), 2); } /** * Calculate probability of both teams to score */ private function calculateBothTeamsToScoreProb(array $matches): float { if (empty($matches)) { return 0.0; } // Filter out matches with invalid score structure $validMatches = array_filter($matches, function(array $match): bool { return isset($match['score']['home']) && isset($match['score']['away']); }); if (empty($validMatches)) { return 0.0; } $bothScoredCount = count(array_filter($validMatches, function(array $match): bool { return (int)$match['score']['home'] > 0 && (int)$match['score']['away'] > 0; })); return round(($bothScoredCount / count($validMatches)) * 100, 2); } /** * Predict winner based on historical head-to-head matches */ private function predictWinner(string $homeTeam, string $awayTeam, array $matches): array { if (empty($homeTeam) || empty($awayTeam) || empty($matches)) { return ['winner' => 'unknown', 'confidence' => 0.0]; } $h2hMatches = array_filter($matches, function(array $match) use ($homeTeam, $awayTeam): bool { return isset($match['home_team']) && isset($match['away_team']) && strcasecmp($match['home_team'], $homeTeam) === 0 && strcasecmp($match['away_team'], $awayTeam) === 0; }); // Filter out matches with invalid score structure $validMatches = array_filter($h2hMatches, function(array $match): bool { return isset($match['score']['home']) && isset($match['score']['away']); }); if (empty($validMatches)) { return ['winner' => 'unknown', 'confidence' => 0.0]; } $stats = array_reduce($validMatches, function(array $acc, array $match): array { $homeScore = (int)$match['score']['home']; $awayScore = (int)$match['score']['away']; if ($homeScore > $awayScore) { $acc['home_wins']++; } elseif ($homeScore < $awayScore) { $acc['away_wins']++; } else { $acc['draws']++; } return $acc; }, ['home_wins' => 0, 'away_wins' => 0, 'draws' => 0]); $totalMatches = count($validMatches); if ($stats['home_wins'] > $stats['away_wins'] && $stats['home_wins'] > $stats['draws']) { return ['winner' => 'home', 'confidence' => round($stats['home_wins'] / $totalMatches, 2)]; } elseif ($stats['away_wins'] > $stats['home_wins'] && $stats['away_wins'] > $stats['draws']) { return ['winner' => 'away', 'confidence' => round($stats['away_wins'] / $totalMatches, 2)]; } else { return ['winner' => 'draw', 'confidence' => round($stats['draws'] / $totalMatches, 2)]; } } /** * Run match prediction analysis */ private function runPrediction(string $homeTeam, string $awayTeam, array $matches): array { $homeExpectedGoals = $this->calculateExpectedGoals($homeTeam, $matches); $awayExpectedGoals = $this->calculateExpectedGoals($awayTeam, $matches); $bothTeamsToScoreProb = $this->calculateBothTeamsToScoreProb($matches); $winnerPrediction = $this->predictWinner($homeTeam, $awayTeam, $matches); return [ 'homeExpectedGoals' => $homeExpectedGoals, 'awayExpectedGoals' => $awayExpectedGoals, 'bothTeamsToScoreProb' => $bothTeamsToScoreProb, 'predictedWinner' => $winnerPrediction['winner'], 'confidence' => $winnerPrediction['confidence'], 'modelPredictions' => [ 'randomForest' => $winnerPrediction['winner'] === 'unknown' ? 'insufficient_data' : $winnerPrediction['winner'] . '_win', 'poisson' => [ 'homeGoals' => round($homeExpectedGoals), 'awayGoals' => round($awayExpectedGoals) ], 'elo' => [ 'homeWinProb' => $this->calculateWinProbability($winnerPrediction, 'home'), 'drawProb' => $this->calculateWinProbability($winnerPrediction, 'draw'), 'awayWinProb' => $this->calculateWinProbability($winnerPrediction, 'away') ] ] ]; } /** * Calculate win probability based on winner prediction and outcome type */ private function calculateWinProbability(array $winnerPrediction, string $outcomeType): float { if ($winnerPrediction['winner'] === 'unknown') { // Equal probability for all outcomes when unknown return round(1/3, 2); } if ($winnerPrediction['winner'] === $outcomeType) { return $winnerPrediction['confidence']; } // Distribute remaining probability among non-predicted outcomes $remainingProb = 1 - $winnerPrediction['confidence']; $nonPredictedOutcomes = 2; // There are always 2 other outcomes (home, away, draw) return round($remainingProb / $nonPredictedOutcomes, 2); } /** * Validate and sanitize input parameters */ private function validateAndSanitizeParams(array $params): array { $sanitizedParams = []; foreach ($params as $key => $value) { // Skip empty values if ($value === '') { continue; } // Sanitize and validate based on parameter type switch ($key) { case 'page': case 'page_size': $sanitizedParams[$key] = filter_var($value, FILTER_VALIDATE_INT) !== false ? (int)$value : null; break; case 'date': // Validate date format try { new \DateTime($value); $sanitizedParams[$key] = htmlspecialchars($value, ENT_QUOTES, 'UTF-8'); } catch (\Exception $e) { // Invalid date, skip this parameter } break; case 'both_teams_scored': // Validate boolean value if (in_array(strtolower($value), ['true', 'false', '1', '0'], true)) { $sanitizedParams[$key] = strtolower($value); } break; case (str_starts_with($key, 'score_')): // Validate score values are numeric if (is_numeric($value)) { $sanitizedParams[$key] = htmlspecialchars($value, ENT_QUOTES, 'UTF-8'); } break; default: // General string parameters $sanitizedParams[$key] = htmlspecialchars($value, ENT_QUOTES, 'UTF-8'); break; } } return $sanitizedParams; } /** * Process API request and return response */ public function processRequest(): array { try { // Sanitize and filter parameters $params = $this->validateAndSanitizeParams($_GET); // Filter matches based on parameters $filteredMatches = $this->filterMatches($this->matches, $params); // Sort matches by date descending usort($filteredMatches, function($a, $b) { $dateA = isset($a['date']) ? strtotime($a['date']) : 0; $dateB = isset($b['date']) ? strtotime($b['date']) : 0; return $dateB <=> $dateA; }); // Pagination $page = isset($params['page']) ? max(1, (int)$params['page']) : 1; $pageSize = isset($params['page_size']) ? min(max(1, (int)$params['page_size']), self::MAX_PAGE_SIZE) : self::DEFAULT_PAGE_SIZE; $totalMatches = count($filteredMatches); $offset = ($page - 1) * $pageSize; $paginatedMatches = array_slice($filteredMatches, $offset, $pageSize); // Team analysis $homeTeam = $params['home_team'] ?? ''; $awayTeam = $params['away_team'] ?? ''; $teamAnalysis = null; $prediction = null; if (!empty($homeTeam) && !empty($awayTeam)) { $teamAnalysisMatches = array_filter($filteredMatches, function(array $match) use ($homeTeam, $awayTeam): bool { return (isset($match['home_team']) && isset($match['away_team'])) && ((strcasecmp($match['home_team'], $homeTeam) === 0 && strcasecmp($match['away_team'], $awayTeam) === 0) || (strcasecmp($match['home_team'], $awayTeam) === 0 && strcasecmp($match['away_team'], $homeTeam) === 0)); }); $teamAnalysis = [ 'home_team' => $homeTeam, 'away_team' => $awayTeam, 'matches_count' => count($teamAnalysisMatches), 'both_teams_scored_percentage' => $this->calculateBothTeamsScoredPercentage($teamAnalysisMatches), 'average_goals' => $this->calculateAverageGoals($teamAnalysisMatches), 'home_form_index' => $this->calculateFormIndex($filteredMatches, $homeTeam), 'away_form_index' => $this->calculateFormIndex($filteredMatches, $awayTeam), 'head_to_head_stats' => $this->calculateHeadToHeadStats($teamAnalysisMatches) ]; $prediction = $this->runPrediction($homeTeam, $awayTeam, $filteredMatches); } return [ 'total_matches' => $totalMatches, 'page' => $page, 'page_size' => $pageSize, 'matches' => array_values($paginatedMatches), 'team_analysis' => $teamAnalysis, 'prediction' => $prediction, 'teams' => $this->getAvailableTeams($this->matches) // Add available teams list ]; } catch (\Exception $e) { http_response_code(500); return [ 'error' => $e->getMessage(), 'file' => $e->getFile(), 'line' => $e->getLine() ]; } } } // Execute the API try { $api = new FootballAPI(); $response = $api->processRequest(); echo json_encode($response, JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE | JSON_THROW_ON_ERROR); } catch (\Exception $e) { http_response_code(500); echo json_encode([ 'error' => 'API execution error: ' . $e->getMessage(), 'trace' => $e->getTraceAsString() ], JSON_PRETTY_PRINT | JSON_UNESCAPED_UNICODE); } ---------------A PHP kód részletes elemzése: Funkciók és működési folyamat Ez a PHP szkript egy teljeskörű, RESTful API-ként működik, amely egy combined_matches.json fájlból származó futballmérkőzés-adatokat dolgoz fel. Képes szűrni, lapozni, statisztikákat számolni és akár predikciókat is adni a mérkőzések kimenetelére vonatkozóan. Az alábbiakban részletesen bemutatom a kód minden funkcióját és működési folyamatát, hogy a fejlesztéshez szükséges teljes képet kapj róla. 1. Alapbeállítások és környezet A kód elején található globális beállítások biztosítják a stabil és biztonságos működést. Szigorú típuskezelés (declare(strict_types=1);): A legelső sorban lévő utasítás bekapcsolja a PHP szigorú típusellenőrzését. Ez azt jelenti, hogy a függvényeknek átadott értékek típusának pontosan meg kell egyeznie a függvénydefinícióban megadott típussal. Ez segít a rejtett hibák korai felismerésében és a kód megbízhatóságának növelésében. Hibakezelés (error_reporting, ini_set): A szkript minden lehetséges hibát és figyelmeztetést kijelez (E_ALL), és ezeket a kimeneten meg is jeleníti (display_errors, '1'). Ez fejlesztés közben rendkívül hasznos a hibakereséshez. Éles (production) környezetben ezt a beállítást ki kell kapcsolni, és a hibákat egy naplófájlba kell irányítani. HTTP Fejlécek (header): Content-Type: application/json: Közli a klienssel (pl. böngésző, mobilalkalmazás), hogy a válasz JSON formátumú. Access-Control-Allow-Origin: *: Engedélyezi, hogy bármilyen domainről érkező weboldal lekérdezhesse az API-t (CORS). Access-Control-Allow-Methods: GET, OPTIONS: Meghatározza, hogy csak GET (adatlekérdezés) és OPTIONS (előzetes ellenőrző) kérések engedélyezettek. Access-Control-Allow-Headers: Content-Type: Megadja, hogy a kliens milyen extra fejléceket küldhet. Előzetes kérések kezelése (OPTIONS metódus): A modern böngészők biztonsági okokból egy ún. "preflight" kérést küldenek az API-hoz, mielőtt a tényleges adatlekérdezés megtörténne. Ez a blokk kezeli ezeket az OPTIONS kéréseket, és egy 204 No Content válasszal jelzi, hogy a kérés elfogadható, így a böngésző továbbküldheti a tényleges GET kérést. 2. A FootballAPI osztály: A logika központja Az osztály tartalmazza az API teljes funkcionalitását, elkülönítve azt a globális szkripttől. Adatbetöltés (loadMatches) Ez a metódus felelős az adatok forrásának, a combined_matches.json fájlnak a beolvasásáért és feldolgozásáért. Ellenőrzés: Megvizsgálja, hogy a fájl létezik-e és olvasható-e. Beolvasás: Beolvassa a fájl tartalmát. Dekódolás: A JSON szöveget PHP tömbbé alakítja. A JSON_THROW_ON_ERROR opció biztosítja, hogy hibás JSON formátum esetén a program kivételt (Exception) dobjon, amit a kód képes kezelni, így nem omlik össze. Tárolás: A dekódolt mérkőzésadatokat az osztály $matches változójában tárolja a memóriában. Szűrési logika (filterMatches, matchParameter és segédfüggvényei) Ez a rendszer teszi lehetővé, hogy az API-t URL paraméterekkel (pl. ?team=Liverpool&date=2024-01-01) lehessen szűrni. filterMatches: A központi szűrő metódus, amely végigmegy az összes mérkőzésen, és azokra alkalmazza a megadott szűrési feltételeket. matchParameter: Egy "elosztó" metódus, amely a szűrési feltétel kulcsa (team, date, score_home stb.) alapján dönti el, hogy melyik specifikus ellenőrző függvényt kell meghívni. Specifikus ellenőrzők (matchesTeam, matchesDate stb.): Ezek a kis függvények végzik a tényleges összehasonlítást. Például a matchesTeam azt nézi, hogy egy csapat akár hazai, akár vendég volt-e, míg a matchesScore a gólok számát ellenőrzi. A strcasecmp használata biztosítja, hogy a szöveges összehasonlítások (pl. csapatnevek) ne legyenek kis- és nagybetű-érzékenyek. Statisztikai és analitikai funkciók Ezek a metódusok a szűrt adatokból számolnak különböző statisztikákat és mutatószámokat. calculateBothTeamsScoredPercentage: Kiszámolja, hogy a meccsek hány százalékán szerzett mindkét csapat gólt (BTTS). calculateAverageGoals: Kiszámítja az átlagos gólok számát meccsenként (összes, hazai, vendég). calculateFormIndex: Egy adott csapat formai mutatóját számolja ki az utolsó 5 mérkőzés eredményei alapján (győzelem: 3 pont, döntetlen: 1 pont), és ezt százalékos formában adja meg. calculateHeadToHeadStats: Két csapat egymás elleni mérlegét számolja ki (hazai győzelmek, vendég győzelmek, döntetlenek). getAvailableTeams: Kigyűjti és visszaadja az összes egyedi csapatnevet, ami az adatbázisban szerepel. Predikciós (Jósló) funkciók A kód képes egyszerűbb predikciókat is adni a historikus adatok alapján. calculateExpectedGoals: Kiszámítja egy csapat várható góljainak számát (xG) a korábbi meccseken szerzett gólok átlaga alapján. predictWinner: Megpróbálja megjósolni a győztest a két csapat korábbi egymás elleni mérkőzései alapján. Azt a kimenetelt (hazai, vendég, döntetlen) jelöli meg győztesként, amelyik a leggyakrabban fordult elő, és egy "konfidencia" értéket is rendel hozzá. runPrediction: Ez a metódus összefogja a különböző predikciós számításokat, és egy strukturált válaszba rendezi őket, beleértve a várható gólokat és a győztes-predikciót is. A modelPredictions részben további, komplexebb modellek (pl. Poisson-eloszlás, Elo-értékelés) eredményeinek is helyet biztosít, bár a jelenlegi implementáció ezeket még csak egyszerűsítve szimulálja. A Fő vezérlő: processRequest() Ez az egyetlen public metódus, ami az API teljes logikáját vezényli le egyetlen hívással. Paraméterek tisztítása (validateAndSanitizeParams): Először is, az URL-ből érkező $_GET paramétereket validálja és "fertőtleníti" (sanitizálja), hogy megelőzze az olyan biztonsági réseket, mint az XSS (Cross-Site Scripting). Szűrés és Rendezés: A megtisztított paraméterek alapján leszűri, majd dátum szerint csökkenő sorrendbe rendezi a mérkőzéseket. Lapozás: A page és page_size paraméterek alapján kiszámolja, hogy a teljes, szűrt listából melyik adathalmazt kell visszaadni az aktuális oldalon. Elemzés és Predikció: Ha a kérésben home_team és away_team is szerepel, lefuttatja a részletes csapatelemzést és a predikciós logikát. Válasz összeállítása: Végül mindent egyetlen, jól strukturált tömbbe rendez: a találatok számát, a lapozás adatait, a mérkőzések listáját, az esetleges elemzéseket és predikciókat, valamint az összes elérhető csapat listáját. Ezt a tömböt adja vissza a hívónak. 3. A szkript futtatása és hibakezelés A kód legvége felelős az API elindításáért. Létrehozza a FootballAPI objektumot, ami azonnal betölti az adatokat. Meghívja a processRequest() metódust, ami elvégzi az összes műveletet és visszaadja a kész választ. A json_encode() függvénnyel a PHP tömböt JSON formátumú szöveggé alakítja, amit a echo kiír a kimenetre. A JSON_PRETTY_PRINT opció olvashatóbbá teszi a JSON-t, ami a fejlesztést segíti. Az egész folyamat egy try-catch blokkba van ágyazva. Ha bármilyen hiba (kivétel) történik – például a JSON fájl nem létezik, vagy hibás a formátuma –, a catch blokk elkapja azt, 500 Internal Server Error HTTP státuszkódot küld, és egy informatív, JSON formátumú hibaüzenetet ad vissza. Ez egy robusztus és professzionális hibakezelési megoldás. Összefoglalás Ez a PHP kód egy jól megtervezett, moduláris és funkciókban gazdag API, amely stabil alapot nyújt a további fejlesztésekhez. Képes adatokat szolgáltatni, azokat dinamikusan szűrni és rendezni, valamint alapvető statisztikai elemzéseket és predikciókat végezni. A szigorú típuskezelés, a biztonságos paraméterkezelés és a robusztus hibakezelés mind a minőségi szoftverfejlesztési gyakorlatokat tükrözik. ////////// az alábbi szöveg bemutatja hogyan készítsd el az új php kodnak a teljes módosított tartalmat : Összefoglalva ezzel a fejlesztési tervezettel modositanám a tartalmat : # Fejlesztési dokumentáció: RESTful Football API Supabase-alapú háttérrel Dátum: 2025. 08. 07. Verzió: 1.0 1. Célkitűzés A rendszer célja egy RESTful API szolgáltatása futballmérkőzésekhez kapcsolódó adatokhoz, melyek: Supabase PostgreSQL adatbázisban tárolódnak Szűrés, lapozás, statisztikák, predikciók elérhetők Minden mérkőzéshez rögzítjük a félidő- és teljesidős eredményeket 2. Magas szintű architektúra Kliens (böngésző, mobilalkalmazás) → HTTP(S) RESTful API (PHP 8+, Composer, PSR-4 autoload) Supabase (PostgreSQL + Realtime + Auth) Kódrétegek Controller (processRequest) Service / Business Logic (filter, stats, predict) Repository (adatbázis-kezelés, Supabase PHP kliens) Modellek (Match, Team, Statistic, Prediction) 3. Adatbázis-terv TáblaMezőTípusLeírásmatchesidUUID PRIMARY KEYEgyedi mérkőzésazonosítódateTIMESTAMPMérkőzés dátumahome_team_idUUIDHazai csapat (külső kulcs)away_team_idUUIDVendég csapat (külső kulcs)full_time_home_goalsSMALLINTTeljesidős hazai gólokfull_time_away_goalsSMALLINTTeljesidős vendég gólokhalf_time_home_goalsSMALLINTFélidős hazai gólokhalf_time_away_goalsSMALLINTFélidős vendég gólokteamsidUUID PRIMARY KEYCsapatazonosítónameTEXT UNIQUECsapatnév Indexelés és optimalizálás INDEX matches(date) INDEX matches(home_team_id) INDEX matches(away_team_id) INDEX matches(full_time_home_goals, full_time_away_goals) 4. API végpontok VégpontMódszerLeírásURL paraméterek/matchesGETMérkőzések listázása, szűrés+lapozásteam, date, min_goals, page, page_size/matches/{id}GETEgy mérkőzés részletei–/teamsGETElérhető csapatok listája–/statsGETÁltalános statisztikák (átlag, BTTS stb.)team/head2headGETKét csapat egymás elleni mutatóhome_team, away_team/predictGETPredikció (xG, nyertes, konfidencia)home_team, away_team 5. Kódszerkezet (példa) code Code downloadcontent_copyexpand_less src/ │ ├─ Controller/ │ └─ ApiController.php # processRequest(), CORS, hibakezelés │ ├─ Service/ │ ├─ MatchService.php # filterMatches(), pagination, stats, predict │ └─ ValidationService.php # param validálás, sanitizálás │ ├─ Repository/ │ └─ MatchRepository.php # Supabase-lekérdezések │ ├─ Model/ │ ├─ Match.php │ ├─ Team.php │ └─ Prediction.php │ └─ config/ └─ config.php # környezeti változók, Supabase kulcsok 6. Supabase konfiguráció Hozz létre egy új projektet Supabase oldalán. Beállítások → API → anon kulcsokat másold config/config.php-be: code PHP downloadcontent_copyexpand_less IGNORE_WHEN_COPYING_START IGNORE_WHEN_COPYING_END return [ 'supabaseUrl' => 'https://xyz.supabase.co', 'supabaseKey' => 'public-anon-key', 'supabaseSecret' => 'service-role-key', ]; Telepítsd a Supabase PHP kliens csomagot (példa): code Bash downloadcontent_copyexpand_less IGNORE_WHEN_COPYING_START IGNORE_WHEN_COPYING_END composer require supabase/supabase-php 7. Migrációs lépések Hozd létre a táblákat a fenti séma szerint SQL migrációs fájlban. Töltsd fel a meglévő JSON adatok alapján az INSERT-eket, a félidőeredményeket is kezelve. Ellenőrizd a rekordok teljességét (pl. NULL helyett 0 ha nincs félidős gól). 8. Szűrés és lapozás Szűrés: építsd fel dinamikusan a WHERE záradékot: team: home_team_id = :team OR away_team_id = :team date: DATE(date) = :date min_goals: full_time_home_goals + full_time_away_goals >= :min_goals Lapozás: code SQL downloadcontent_copyexpand_less IGNORE_WHEN_COPYING_START IGNORE_WHEN_COPYING_END LIMIT :page_size OFFSET (:page - 1) * :page_size 9. Statisztikák és predikció BTTS százalék [ \frac{\text{mindkét csapat gólt szerzett meccsek száma}}{\text{összes meccs}} \times 100 ] Átlaggól Teljesidős: AVG(full_time_home_goals + full_time_away_goals) Félidős: AVG(half_time_home_goals + half_time_away_goals) Form-index: utolsó 5 meccs bejárása, pontszámok 3–1–0 alapján Head2Head: COUNT a mérkőzés eredményei szerint xG: AVG(full_time_*_goals) Győztes-predikció: leggyakoribb head-to-head kimenetel + konfidencia = arány 10. Hibakezelés és loggolás Globális try–catch a Controller-ben Hibakódok: 400 (Bad Request), 404 (Not Found), 500 (Server Error) Naplózás: Monolog + napi forrott logfájl 11. Biztonság és CORS CORS beállítás: code PHP downloadcontent_copyexpand_less IGNORE_WHEN_COPYING_START IGNORE_WHEN_COPYING_END header('Access-Control-Allow-Origin: *'); header('Access-Control-Allow-Methods: GET, OPTIONS'); header('Access-Control-Allow-Headers: Content-Type, Authorization'); Supabase Auth: opcionálisan token ellenőrzés minden kérés előtt 12. Jövőbeli bővítések WebSocket alapú realtime frissítés Supabase Realtime segítségével Bővített predikció: Poisson-modell, gépi tanulás Rate limiting és API kulcskezelés Ez a dokumentáció szolgál alapként a Supabase-alapú, félidőeredménnyel bővített futbol-API kialakításához. A moduláris felépítés és a szolgáltatás-orientált rétegezés biztosítja a könnyű bővíthetőséget és karbantarthatóságot.
